"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const esbuild_1 = require("esbuild");
const path_1 = require("path");
const kleur_1 = require("kleur");
const yakumo_1 = require("yakumo");
const tsconfig_utils_1 = require("tsconfig-utils");
const globby_1 = __importDefault(require("globby"));
const ignored = [
    'This call to "require" will not be bundled because the argument is not a string literal',
    'Indirect calls to "require" will not be bundled',
    'should be marked as external for use with "require.resolve"',
];
function display(prefix) {
    return ({ location, text }) => {
        if (ignored.some(message => text.includes(message)))
            return;
        if (!location)
            return console.log(prefix, text);
        const { file, line, column } = location;
        console.log((0, kleur_1.cyan)(`${file}:${line}:${column}:`), prefix, text);
    };
}
const displayError = display((0, kleur_1.red)('error:'));
const displayWarning = display((0, kleur_1.yellow)('warning:'));
let code = 0;
function bundle(options) {
    // show entry list
    for (const [key, value] of Object.entries(options.entryPoints)) {
        const source = (0, path_1.relative)(process.cwd(), value);
        const target = (0, path_1.relative)(process.cwd(), (0, path_1.resolve)(options.outdir, key + options.outExtension['.js']));
        console.log('esbuild:', source, '->', target);
    }
    return (0, esbuild_1.build)(options).then(({ warnings }) => {
        warnings.forEach(displayWarning);
    }, ({ warnings, errors }) => {
        errors.forEach(displayError);
        warnings.forEach(displayWarning);
        code += errors.length;
    });
}
async function compile(relpath, meta, project) {
    // filter out private packages
    if (meta.private)
        return [];
    const filter = /^[@\w].+$/;
    const externalPlugin = {
        name: 'external library',
        setup(build) {
            const { entryPoints, platform, format } = build.initialOptions;
            const currentEntry = Object.values(entryPoints)[0];
            build.onResolve({ filter }, (args) => {
                if ((0, path_1.isAbsolute)(args.path))
                    return null;
                return { external: true };
            });
            build.onResolve({ filter: /^\./, namespace: 'file' }, async (args) => {
                const { path } = await build.resolve(args.path, {
                    namespace: 'internal',
                    importer: args.importer,
                    resolveDir: args.resolveDir,
                    kind: args.kind,
                });
                if (currentEntry === path || !exports[path])
                    return null;
                if (format === 'cjs')
                    return { external: true };
                // native ESM import should preserve extensions
                const outFile = exports[path][platform] || exports[path].default;
                if (!outFile)
                    return null;
                const outDir = (0, path_1.dirname)(exports[currentEntry][platform]);
                let relpath = (0, path_1.relative)(outDir, outFile);
                if (!relpath.startsWith('.'))
                    relpath = './' + relpath;
                return { path: relpath, external: true };
            });
        },
    };
    const base = project.cwd + relpath;
    const config = await (0, tsconfig_utils_1.load)(base);
    const { rootDir, outFile, noEmit, emitDeclarationOnly, sourceMap } = config.compilerOptions;
    if (!noEmit && !emitDeclarationOnly)
        return [];
    const outDir = config.compilerOptions.outDir ?? (0, path_1.dirname)(outFile);
    const nodeOptions = {
        platform: 'node',
        target: 'node12',
        format: 'cjs',
    };
    const browserOptions = {
        platform: 'browser',
        target: 'esnext',
        format: 'esm',
    };
    const outdir = (0, path_1.join)(base, outDir);
    const outbase = (0, path_1.join)(base, rootDir);
    const matrix = [];
    const exports = Object.create(null);
    const outFiles = new Set();
    function addExport(pattern, options) {
        if (!pattern)
            return;
        if (pattern.startsWith('./'))
            pattern = pattern.slice(2);
        if (!pattern.startsWith(outDir + '/')) {
            // handle files like `package.json`
            pattern = pattern.replace('*', '**');
            const targets = globby_1.default.sync(pattern, { cwd: base });
            for (const target of targets) {
                // ignore exports in `rootDir`
                if (!(0, path_1.relative)(rootDir, target).startsWith('../'))
                    continue;
                const filename = (0, path_1.join)(base, target);
                exports[filename] = { default: filename };
            }
            return;
        }
        // https://nodejs.org/api/packages.html#subpath-patterns
        // `*` maps expose nested subpaths as it is a string replacement syntax only
        const outExt = (0, path_1.extname)(pattern);
        pattern = pattern.slice(outDir.length + 1, -outExt.length).replace('*', '**') + '.{ts,tsx}';
        const targets = globby_1.default.sync(pattern, { cwd: outbase });
        for (const target of targets) {
            const srcFile = (0, path_1.join)(base, rootDir, target);
            const srcExt = (0, path_1.extname)(target);
            const entry = target.slice(0, -srcExt.length);
            const outFile = (0, path_1.join)(outdir, entry + outExt);
            if (outFiles.has(outFile))
                return;
            outFiles.add(outFile);
            (exports[srcFile] ||= {})[options.platform] = outFile;
            matrix.push({
                outdir,
                outbase,
                outExtension: { '.js': outExt },
                entryPoints: { [entry]: srcFile },
                bundle: true,
                sourcemap: sourceMap,
                sourcesContent: false,
                keepNames: true,
                charset: 'utf8',
                logLevel: 'silent',
                plugins: [externalPlugin],
                resolveExtensions: ['.tsx', '.ts', '.jsx', '.js', '.css', '.json'],
                tsconfig: base + '/tsconfig.json',
                ...options,
            });
        }
    }
    // TODO: support null targets
    function addConditionalExport(pattern, options) {
        if (typeof pattern === 'string') {
            return addExport(pattern, options);
        }
        for (const key in pattern) {
            if (key === 'node' || key === 'require' || key.startsWith('.')) {
                addConditionalExport(pattern[key], nodeOptions);
            }
            else {
                addConditionalExport(pattern[key], browserOptions);
            }
        }
    }
    addExport(meta.main, meta.type === 'module' ? browserOptions : nodeOptions);
    addExport(meta.module, browserOptions);
    addConditionalExport(meta.exports, nodeOptions);
    if (!meta.exports) {
        addExport('package.json', nodeOptions);
    }
    if (typeof meta.bin === 'string') {
        addExport(meta.bin, nodeOptions);
    }
    else if (meta.bin) {
        for (const key in meta.bin) {
            addExport(meta.bin[key], nodeOptions);
        }
    }
    return matrix;
}
(0, yakumo_1.register)('esbuild', async (project) => {
    await Promise.all(Object.entries(project.targets).map(async ([key, value]) => {
        const matrix = await compile(key, value, project);
        await Promise.all(matrix.map(async (options) => {
            await project.emit('esbuild.before', options, value);
            await bundle(options);
            await project.emit('esbuild.after', options, value);
        })).catch(console.error);
    }));
    if (code)
        process.exit(code);
});
