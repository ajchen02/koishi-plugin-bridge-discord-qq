"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const yakumo_1 = require("yakumo");
const tsconfig_utils_1 = require("tsconfig-utils");
const atsc = __importStar(require("atsc"));
const dtsc = __importStar(require("dtsc"));
(0, yakumo_1.register)('tsc', async (project) => {
    var _a;
    const { targets, argv } = project;
    // build clean
    if (argv.clean) {
        const tasks = Object.keys(targets).map(async (path) => {
            var _a;
            const fullpath = (0, path_1.join)(yakumo_1.cwd, path);
            const tsconfig = await (0, tsconfig_utils_1.load)(fullpath);
            await Promise.all([
                fs_1.promises.rm((0, path_1.join)(yakumo_1.cwd, path, ((_a = tsconfig === null || tsconfig === void 0 ? void 0 : tsconfig.compilerOptions) === null || _a === void 0 ? void 0 : _a.outDir) || 'lib'), { recursive: true }),
                fs_1.promises.rm((0, path_1.join)(fullpath, 'tsconfig.tsbuildinfo')),
            ]);
        });
        tasks.push(fs_1.promises.rm((0, path_1.join)(yakumo_1.cwd, 'tsconfig.temp.json')));
        await Promise.allSettled(tasks);
        return;
    }
    // Step 1: initialize nodes
    const nodes = {};
    for (const path in targets) {
        const meta = targets[path];
        if (!meta.main && !meta.exports)
            continue;
        const fullpath = (0, path_1.join)(yakumo_1.cwd, path);
        try {
            const config = await (0, tsconfig_utils_1.load)(fullpath);
            const bundle = !!((_a = config.compilerOptions) === null || _a === void 0 ? void 0 : _a.outFile);
            nodes[meta.name] = { bundle, path, meta, prev: [], next: new Set() };
        }
        catch { }
    }
    // Step 2: build dependency graph
    for (const name in nodes) {
        const { meta } = nodes[name];
        const deps = {
            ...meta.dependencies,
            ...meta.devDependencies,
            ...meta.peerDependencies,
        };
        for (const dep in deps) {
            if (!nodes[dep])
                continue;
            nodes[name].prev.push(dep);
            nodes[dep].next.add(name);
        }
        delete nodes[name].meta;
    }
    // Step 3: generate bundle workflow
    let bundle = false;
    const layers = [];
    while (Object.keys(nodes).length) {
        const layer = [];
        bundle = !bundle;
        let flag = true;
        while (flag) {
            flag = false;
            for (const name of Object.keys(nodes)) {
                const node = nodes[name];
                if (node.next.size || node.bundle === bundle)
                    continue;
                flag = true;
                layer.unshift(node);
                delete nodes[name];
                node.prev.forEach((prev) => {
                    nodes[prev].next.delete(name);
                });
            }
        }
        if (layers.length && !layer.length) {
            console.log(nodes);
            throw new Error('circular dependency detected');
        }
        layers.unshift(layer);
    }
    // Step 4: generate dts files
    // make sure the number of layers is even
    if (bundle)
        layers.unshift([]);
    for (let i = 0; i < layers.length; i += 2) {
        const bundleTargets = layers[i];
        const buildTargets = layers[i + 1];
        const tasks = buildTargets.map(node => atsc.build((0, path_1.join)(yakumo_1.cwd, node.path)));
        await Promise.all([
            prepareBuild(buildTargets),
            bundleNodes(bundleTargets),
        ]);
        if (buildTargets.length) {
            const code = await (0, tsconfig_utils_1.compile)(['-b', 'tsconfig.temp.json']);
            if (code)
                process.exit(code);
        }
        await Promise.all(tasks);
    }
});
async function prepareBuild(nodes) {
    if (!nodes.length)
        return;
    await fs_1.promises.writeFile(yakumo_1.cwd + '/tsconfig.temp.json', JSON.stringify({
        files: [],
        references: nodes.map(node => ({ path: '.' + node.path })),
    }, null, 2));
}
async function bundleNodes(nodes) {
    for (const node of nodes) {
        await dtsc.build((0, path_1.join)(yakumo_1.cwd, node.path));
    }
}
